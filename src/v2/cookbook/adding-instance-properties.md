---
title: Προσθήκη ιδιοτήτων σε στιγμιότυπα
type: cookbook
order: 2
---

## Βασικό Παράδειγμα

Ενδέχεται να υπάρχουν δεδομένα/βοηθητικά προγράμματα που μπορείτε να χρησιμοποιήσετε σε πολλά μέρη, αλλά δεν θέλετε να [αλλοιώσετε το παγκόσμιο πεδίο εφαρμογής](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md). Σε αυτές τις περιπτώσεις, μπορείτε να τα θέσετε στη διάθεση κάθε στιγμιοτύπου της Vue ορίζοντάς τα στο πρωτότυπο:

```js
Vue.prototype.$appName = 'My App'
```

Τώρα το `$appName` είναι διαθέσιμο σε όλα τα στιγμιότυπα της Vue, ακόμα και πριν την δημιουργία τους. Αν εκτελέσουμε:

```js
new Vue({
  beforeCreate: function() {
    console.log(this.$appName)
  }
})
```

Τότε η φράση `"My App"` θα καταγραφεί στην κονσόλα!

## Η σημασία του ορισμού του πεδίου εφαρμογής των ιδιοτήτων στιγμιοτύπων

Ίσως να αναρωτιέστε:

> "Γιατί ξεκινά το `appName` με `$`; Είναι σημαντικό΄; Τι κάνει αυτό;"

Δεν υπάρχει καμία μαγεία εδώ. Το `$` είναι μια σύμβαση που χρησιμοποιεί η Vue για ιδιότητες που είναι διαθέσιμες σε όλα τα στιγμιότυπα. Αυτό αποτρέπει τις συγκρούσεις με οποιασδήποτε καθορισμένα δεδομένα, υπολογισμένες ιδιότητες ή μεθόδους.

> "Συγκρούσεις; Τι σημαίνει αυτό;"

Ακόμη μία πολύ καλή ερώτηση! Αν θέσετε:

```js
Vue.prototype.appName = 'My App'
```

Τότε τι θα περιμένατε να καταγραφεί παρακάτω;

```js
new Vue({
  data: {
    // Ουπς - το appName είναι *επίσης* το όνομα
    // της ιδιότητας στιγμιοτύπου που καθορίσαμε!
    appName: 'The name of some other app'
  },
  beforeCreate: function() {
    console.log(this.appName)
  },
  created: function() {
    console.log(this.appName)
  }
})
```

Θα ήταν `"My App"`, και στη συνέχεια `"The name of some other app"`, επειδή το `this.appName` έχει αντικατασταθεί ([περίπου](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch5.md)) από τα δεδομένα `data` κατά τη δημιουργία του στιγμιοτύπου. Θέτουμε το πεδίο εφαρμογής των ιδιοτήτων στιγμιοτύπου με το `$` για να το αποφύγουμε. Μπορείτε ακόμα και να χρησιμοποιήσετε κάποια δική σας σύμβαση αν θέλετε, όπως `$_appName` ή `ΩappName`, για να αποφύγετε τις συγκρούσεις με προσθήκες ή μελλοντικά χαρακτηριστικά.

## Πραγματικό παράδειγμα: Αντικατάσταση πόρων της Vue με Axios

Ας υποθέσουμε ότι αντικαθιστάτε τον [πλέον μη διαθέσιμο πόρο της Vue](https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4). Απολαύσατε πραγματικά την δυνατότητα πρόσβασης σε μεθόδους αίτησης μέσω του `this.$http` και θέλετε να κάνετε το ίδιο πράγμα με το Axios.

Το μόνο που έχετε να κάνετε είναι να συμπεριλάβετε το axios στο πρόγραμμα σας:

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js"></script>

<div id="app">
  <ul>
    <li v-for="user in users">{{ user.name }}</li>
  </ul>
</div>
```

Θέστε το ψευδώνυμο `axios` για `Vue.prototype.$http`:

```js
Vue.prototype.$http = axios
```

Στη συνέχεια, θα μπορείτε να χρησιμοποιήσετε μεθόδους όπως `this.$http.get` σε οποιοδήποτε στιγμιότυπο της Vue:

```js
new Vue({
  el: '#app',
  data: {
    users: []
  },
  created() {
    var vm = this
    this.$http
      .get('https://jsonplaceholder.typicode.com/users')
      .then(function(response) {
        vm.users = response.data
      })
  }
})
```

## Το γενικό πλαίσιο των μεθόδων πρωτοτύπου

Σε περίπτωση που δεν το γνωρίζετε, οι μέθοδοι που προστίθενται σε ένα πρωτότυπο της JavaScript αποκτούν το γενικό πλαίσιο του στιγμιοτύπου. Αυτό σημαίνει ότι μπορούν να χρησιμοποιήσουν το `this` για να αποκτήσουν πρόσβαση σε δεδομένα, υπολογιζόμενες ιδιότητες, μεθόδους ή ο,τιδήποτε άλλο ορίζεται στο στιγμιότυπο.

Ας επωφεληθούμε από αυτό σε μια μέθοδο `$reverseText`:

```js
Vue.prototype.$reverseText = function(propertyName) {
  this[propertyName] = this[propertyName]
    .split('')
    .reverse()
    .join('')
}

new Vue({
  data: {
    message: 'Hello'
  },
  created: function() {
    console.log(this.message) // => "Hello"
    this.$reverseText('message')
    console.log(this.message) // => "olleH"
  }
})
```

Σημειώστε ότι η δέσμευση πλαισίου **δεν** θα λειτουργήσει αν χρησιμοποιείτε μία ES6/2015 συνάρτηση βέλους, καθώς συνδέονται έμμεσα με το γονικό τους πεδίο. Αυτό σημαίνει πως η επόμενη έκδοση συνάρτησης βέλους:

```js
Vue.prototype.$reverseText = propertyName => {
  this[propertyName] = this[propertyName]
    .split('')
    .reverse()
    .join('')
}
```

Θα παράγει ένα σφάλμα(error):

```log
Uncaught TypeError: Cannot read property 'split' of undefined
```

## Πότε πρέπει να αποφύγετε αυτό το μοτίβο

Εφόσον είστε προσεκτικοί όσον αφορά το πεδίο εφαρμογής των ιδιοτήτων πρωτοτύπου, η χρήση αυτού του μοτίβου είναι ιδιαίτερα ασφαλής - αυτό σημαίνει πως είναι απίθανο να παράγει σφάλματα (bugs).

Ωστόσο, μπορεί μερικές φορές να προκαλέσει σύγχυση με άλλους προγραμματιστές. Μπορεί να δουν αυτό το `this.$http`, για παράδειγμα, και να σκεφτούν, «Ω, δεν ήξερα για αυτό το χαρακτηριστικό της Vue!". Στη συνέχεια, δουλεύουν σε ένα διαφορετικό πρόγραμμα και μπερδεύονται όταν το `this.$http` είναι απροσδιόριστο. Ή ίσως θέλουν να ψάξουν στο Google πώς να κάνουν κάτι, αλλά δεν μπορούν να βρουν αποτελέσματα επειδή δεν συνειδητοποιούν ότι χρησιμοποιούν το Axios υπό ψευδώνυμο.

**Η ευκολία έχει ως τίμημα την σαφήνεια.** Όταν εξετάζουμε ένα στοιχείο, είναι αδύνατο να πούμε από πού προέρχεται το `$http`. Από την ίδια την Vue; Από μία προσθήκη; Από έναν συνάδελφο;

Ποιες είναι οι εναλλακτικές λύσεις;

## Εναλλακτικά μοτίβα

### Όταν δεν χρησιμοποιείτε σύστημα ενοτήτων (Module System)

Σε εφαρμογές **χωρίς** σύστημα ενοτήτων (π.χ. με Webpack ή Browserify), υπάρχει ένα μοτίβο που χρησιμοποιείται συχνά με  _οποιοδήποτε_ frontend, ενισχυμένο με JavaScript: ένα καθολικό `App` αντικείμενο.

Εάν αυτό που θέλετε να προσθέσετε δεν έχει καμία σχέση με την Vue συγκεκριμένα, αυτό μπορεί να αποτελέσει μια καλή εναλλακτική λύση. Ακολουθεί ένα παράδειγμα:

```js
var App = Object.freeze({
  name: 'My App',
  version: '2.1.4',
  helpers: {
    // Αυτή είναι μια καθαρά λειτουργική έκδοση της
    // μεθόδου $reverseText που είδαμε νωρίτερα
    reverseText: function(text) {
      return text
        .split('')
        .reverse()
        .join('')
    }
  }
})
```

<p class="tip">Αν αναρωτηθήκατε τι αποτρέπει κάποια μελλοντική αλλαγή του `Object.freeze`. Αυτό ουσιαστικά κάνει όλες τις ιδιότητές του σταθερές, προστατεύοντάς σας από μελλοντικά σφάλματα κατάστασης.</p>

Τώρα η πηγή αυτών των κοινών ιδιοτήτων είναι πιο προφανής: υπάρχει ένα αντικείμενο `App` που ορίζεται κάπου στην εφαρμογή. Για να το βρουν, οι προγραμματιστές μπορούν να εκτελέσουν μια αναζήτηση σε ολόκληρο το πρόγραμμα.

Ένα άλλο πλεονέκτημα είναι ότι το `App` μπορεί τώρα να χρησιμοποιηθεί _οπουδήποτε_ στον κώδικα σας, είτε αφορά την Vue είτε όχι. Αυτό συμπεριλαμβάνει την προσάρτηση τιμών απευθείας σε επιλογές στιγμιότυπων, αντί να χρειάζεται να εισάγετε μια συνάρτηση για να έχετε προόσβαση στις ιδιότητες του `this`:

```js
new Vue({
  data: {
    appVersion: App.version
  },
  methods: {
    reverseText: App.helpers.reverseText
  }
})
```

###  Όταν χρησιμοποιείτε σύστημα ενοτήτων (Module System)

Όταν έχετε πρόσβαση σε ένα σύστημα ενοτήτων, μπορείτε να οργανώσετε εύκολα τον κοινό κώδικα σε ενότητες, και στην συνέχεια να καλείτε `require`/`import` για αυτές τις ενότητες όταν είναι αναγκαίες. Αυτή είναι η επιτομή της σαφήνειας, επειδή σε κάθε αρχείο αποκτάτε μια λίστα εξαρτήσεων. Ξέρετε _ακριβώς_ από πού προέρχεται η καθεμία.

Παρόλο που είναι σίγουρα πιο λεπτομερής, αυτή η προσέγγιση είναι σίγουρα η πιο συντηρητική, ειδικά όταν συνεργάζεστε με άλλους προγραμματιστές ή/και δημιουργείτε μια μεγάλη εφαρμογή.
